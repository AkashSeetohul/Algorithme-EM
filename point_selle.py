# -*- coding: utf-8 -*-
"""Point Selle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16XZE75M6GkBtUw_BUK6g83Hqerh25G47
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import axes3d

# fonction de la log-vraisemblance complete de la vecteur gausienne avec les données manquantes
def fonction_log_vraisemblance(sigma, rho):
  donnee_complete = np.array([[1, 1, -1, -1], [1, -1, 1, -1]])

  matrice_covariance = [[sigma, rho*sigma], [sigma*rho, sigma]]
  matrice_covariance_inverse = np.linalg.inv(matrice_covariance)

  f = -12*math.log(2*math.pi) - 2*math.log(abs(np.linalg.det(matrice_covariance)))

  for indice in range(donnee_complete.shape[1]):
    f -= 0.5 * np.dot(np.matmul(matrice_covariance_inverse, donnee_complete[:, indice]), donnee_complete[:, indice])

  f -=  4*math.log(sigma) + (16/sigma)

  return(f)

# calculation des paramètres à chaque étape
rho_ = np.zeros(1001)
sigma = np.zeros(1001)
sigma[0] = 1.5

num_iteration = 0
while num_iteration < 1000:
  num_iteration += 1
  sigma[num_iteration] = (5 + sigma[num_iteration - 1])/3
  rho = 0

rho_support = np.arange(start=-0.6, stop=0.6, step=0.1)
sigma_support= np.arange(start=1.5, stop=3, step=0.1)

z = np.zeros((len(rho_support), len(sigma_support)))

for i in range(len(rho_support)):
  for j in range(len(sigma_support)):
      z[i,j]= fonction_log_vraisemblance(sigma_support[j], rho_support[i])

x,y = np.meshgrid(sigma_support, rho_support)

#contours = plt.contour(x, y, z, 25)
#plt.clabel(contours, inline=True, fontsize=10)

#plt.plot(sigma, rho_,'g^', label='Progression de l\'algorithm E-M')

fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
ax.plot_surface(x, y, z, alpha=0.7)
ax.plot(2.5, 0, fonction_log_vraisemblance(sigma=2.5, rho=0), marker='o', color='r', label='Point Selle')

ax.view_init(azim=60, elev = 40)

plt.xlabel(r'$\sigma^{2}$')
plt.ylabel(r'$\rho$')
plt.legend()
plt.show()